---
title: "Sample loading and quality control"
authors: Corentin Bernou, Alexandra Chicheportiche, LÃ©a Bellenger
output:
  html_document:
    df_print: paged
---

### Loading Samples and set up

Loading libraries
Note: please make sure to use both Seurat v4.1.1 and SeuratObject v4.1.0 to reproduce this analysis,
as later versions of either packages change the outcome of the RunUmap function.

```{r}
library(remotes)
library(Seurat)
library(tidyverse)
library(dplyr)
library(biomaRt)
library(ggplot2)
library(patchwork)

Ensembl_gene <- useEnsembl(biomart = "genes", dataset = "mmusculus_gene_ensembl")
```

Loading all samples and creating list of seurat objects; teh list will be used until integration
```{r}

Sample_names <- c("CTRL_1", "CTRL_2", "4Gy_1", "4Gy_2")

Sample_list <- 
  lapply(X = Sample_names, FUN = function(sample){
    Read10X(data.dir = paste0("All_inputs/Samples/SVZ_", sample),
            gene.column = 1,
            cell.column = 1,
            unique.features = TRUE,
            strip.suffix = TRUE) %>%
      CreateSeuratObject(project = sample,
                         assay = "RNA",
                         min.cells = 0,
                         min.features = 1)
  })
```

Use BioMart as a reference for all features (features are shared amongst samples)
```{r}
Biomart_annotated <- getBM(attributes = c("ensembl_gene_id", 
                                          "external_gene_name",
                                          "description",
                                          "chromosome_name"),
                           filters = "ensembl_gene_id", 
                           values = rownames(Sample_list[[1]]),
                           mart = Ensembl_gene) 
write_csv(Biomart_annotated, file = "Analysis_tools/Biomart_annotated.csv")
```

Create variables for easy calling of Ensembl Id from External Gene Name (or vice-versa)
```{r}
geneIDs <- # For easy calling of genes through external gene name
  Biomart_annotated[!duplicated(Biomart_annotated$external_gene_name),1]
names(geneIDs) <- Biomart_annotated[!duplicated(Biomart_annotated$external_gene_name),2]
write.csv(x = geneIDs, file = "Analysis_tools/geneIDs.csv")
```

### Quality controls

Extract mitochondrial gene list 
```{r}
MT_genes <- subset(Biomart_annotated,
                   chromosome_name == "MT")$ensembl_gene_id
```

Calculate percentage of mitochondrial genes
```{r}
Sample_list <- lapply(X= Sample_list, FUN = PercentageFeatureSet, 
                   features = MT_genes,
                   col.name = "Percent.mito")
```

Pre-filter cells containing very few features & counts
```{r}
Sample_list <- lapply(X =  Sample_list, FUN = subset,
                   nCount_RNA > 100 & nFeature_RNA > 200)
```

Choose cutoff for features, count minimmums & counts maximum
```{r}
nFeatures_cutoff <- c(1500, 1500, 1800, 1500)
nCounts_cutoff <- c(2350, 2600, 2700, 2700)
nCounts_upper <- c(48000, 54000, 48000, 54000)
```

Create temporary merged object for violin representation of count & feature distribution
```{r}
Temp_merge <- merge(x = Sample_list[[1]],
                    y = c(Sample_list[[2]], Sample_list[[3]], Sample_list[[4]]),
                    add.cell.ids = Sample_names)
VlnPlot(Temp_merge, features = "nCount_RNA", pt.size = 0) + 
    scale_y_continuous(limits = c(200,60000), trans = "log2", breaks = c(100,1000,2000,5000,10000,30000,60000))
VlnPlot(Temp_merge, features = "nFeature_RNA", pt.size = 0) + 
    scale_y_continuous(limits = c(200,15000), trans = "log2", breaks = c(200,1000,2000,5000,10000,15000))
rm(Temp_merge)
```

Histogram representation of cutoff points
```{r}
Hist_cutoffs <- lapply(X = 1:4, FUN = function(spl_nb){
  ggplot(Sample_list[[spl_nb]]@meta.data,
      aes(x = nFeature_RNA, y = nCount_RNA, colour = Percent.mito)) +
      geom_point() + scale_color_gradient2(low = "green", mid = "yellow",
                                           high = "red", midpoint = 20) +
      geom_hline(yintercept = nCounts_cutoff[spl_nb]) +
      geom_hline(yintercept = nCounts_upper[spl_nb]) +
      geom_vline(xintercept = nFeatures_cutoff[spl_nb]) +
    scale_y_log10() + ggtitle(label = Sample_list[[spl_nb]]@project.name)
})
(Hist_cutoffs[[1]] + Hist_cutoffs[[2]])/(Hist_cutoffs[[3]] + Hist_cutoffs[[4]])+ 
  plot_layout(guides = 'collect')
```
Subsetting cells that meet Feature, Genes, and mitochondrial content criterias.

In this analysis, we retained only cells containing <10% of mitochondrial genes.
```{r}
Sample_list <- mapply(
  FUN = function(object, nC, nF, nC_up) {
    return(subset(
      object, (nCount_RNA > nC &
                 nFeature_RNA > nF &
                 Percent.mito < 10 &
                 nCount_RNA < nC_up)))},
  object = Sample_list,
  nC = nCounts_cutoff,
  nF = nFeatures_cutoff,
  nC_up = nCounts_upper)
```

Useful metadata addition & object save

```{r}
Sample_list <- lapply(X = 1:4, FUN = function(Spl_nb){
  Sample_list[[Spl_nb]]$id_sequence <- colnames(Sample_list[[Spl_nb]])
  ID <- paste0(colnames(Sample_list[[Spl_nb]]), "_", Spl_nb)
  names(ID) <- colnames(Sample_list[[Spl_nb]])
  Sample_list[[Spl_nb]]$id <- ID
  return(Sample_list[[Spl_nb]])
})
saveRDS(Sample_list, file = "Objects/Sample_list_after_subset.rds")
```



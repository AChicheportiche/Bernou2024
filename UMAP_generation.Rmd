---
title: "Cell cycle scoring and UMAP generation"
authors: Corentin Bernou, Alexandra Chicheportiche, Léa Bellenger
output:
  html_document:
    df_print: paged
---

In this script, we use the CellCycle Scoring function of Seurat, generate a UMAP and cluster cells together.

```{r Librairies}
library(tidyverse)
library(dplyr)
library(clustree)
library(patchwork)
#pour savoir ou sont localises les differentes librairies (user et system)
.libPaths()
#en ayant mis le pacakage dans mon projet pour être sûr qu'il le trouve
library(Seurat, lib.loc = "/opt/rstudio-server_conda/conda/envs/rstudio-server_4.1.0/lib/R/library/")
#library(SeuratObject, lib.loc = "/opt/rstudio-server_conda/conda/envs/rstudio-server_4.1.0/lib/R/library/") 
```

Import objects
```{r Object loading}
SCT_obj <- readRDS("Objects/SCT_obj.rds")
Biomart_annotated <- read.csv("Analysis_tools/Biomart_annotated.csv")
```

The cell cycle scoring feature of seurat affects a S and G2/M score to each cell.
For basic classification, cell cycle status can be inferred from the difference between S and G2M score
```{r Cell Cycle scoring}
DefaultAssay(SCT_obj) <- "SCT"
cc.genes.mouse <- lapply(X = cc.genes.updated.2019, FUN = str_to_sentence)
cc.mouse.ok <- lapply(X = cc.genes.mouse, function(gene_vector){
  return(Biomart_annotated[Biomart_annotated$external_gene_name %in% gene_vector,1])})
SCT_obj <- CellCycleScoring(SCT_obj, 
                            s.features = cc.mouse.ok$s.genes,
                            g2m.features = cc.mouse.ok$g2m.genes)
# A Diff score can be used to regress the cell cycle
SCT_obj$diff_score <- SCT_obj$S.Score - SCT_obj$G2M.Score
```

Run PCA and assess explained variance using ElbowPlot
```{r PCA Run}
DefaultAssay(SCT_obj) <- "integrated"
SCT_obj <- RunPCA(object = SCT_obj)
((PCAPlot(SCT_obj, group.by = "orig.ident")+
    ElbowPlot(SCT_obj, ndims = 50, reduction = "pca"))+
    plot_layout(guides = 'collect'))
```

UMAP is created using the first 50 PCs and clusterization is performed based on that graph.
Clustree is used to determine optimal resolution
```{r UMAP and clustering}

DefaultAssay(SCT_obj) <- "integrated"
SCT_obj <- RunUMAP(SCT_obj,
                   dims = 1:50,
                   n.components = 2L, # 3L for downstream 3D UMAP representation, will affect 2D UMAP
                   assay = "integrated",
                   return.model = T) # Useful for downstream pseudotime applications 

UMAPPlot(object = SCT_obj, group.by = "orig.ident")
SCT_obj <- FindNeighbors(SCT_obj, k.param = 20, dims = c(1:50), reduction = "pca",
                         graph.name = c("int_20_nn", "int_20_snn"))
resolutions <- 1.2#seq(0.2,1.6, 0.2)
SCT_obj <- FindClusters(SCT_obj, 
                        graph.name = "int_20_snn", 
                        resolution = resolutions)
# pdf("Analysis_tools/UMAP_resolutions.pdf")
# lapply(X = resolutions, FUN = function(resolv){
#   print(UMAPPlot(SCT_obj, 
#                  group.by = paste0("int_20_snn_res.", resolv), label = T))
#   return()})
# dev.off()
```

Based on these data, we found resolution 1.2 to be optimal to distinguish between NPC populations
```{r}
SCT_obj$clusters <- SCT_obj$int_20_snn_res.1.2
UMAPPlot(SCT_obj, group.by = "clusters")
```

Adding irradiation status metadata on samples
```{r}
Idents(SCT_obj) <- "orig.ident"
Status_info <- c("CTL","CTL", "IRR","IRR")
Sample_names <- as.factor(c("CTRL_1", "CTRL_2", "4Gy_1", "4Gy_2"))
names(Status_info) <- Sample_names
SCT_obj <- RenameIdents(SCT_obj, Status_info)
SCT_obj$Status <- Idents(SCT_obj)
# 
# saveRDS(object = SCT_obj, file = "Objects/SCT_obj_umap.rds")
```

```{r}
sessionInfo()
```


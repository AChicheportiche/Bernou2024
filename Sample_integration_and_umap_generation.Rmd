---
title: "Sample loading and quality control"
authors: Corentin Bernou, Alexandra Chicheportiche, LÃ©a Bellenger
output:
  html_document:
    df_print: paged
---

### Loading Samples and set up

Getting Ensembl gene information 

```{r}
library(remotes)
library(tidyverse)
library(dplyr)
library(biomaRt)
library(ggplot2)
library(patchwork)
library(clustree)
library(Seurat)

Ensembl_gene <- useEnsembl(biomart = "genes", dataset = "mmusculus_gene_ensembl")
```

Loading all samples and creating list of seurat objects; teh list will be used until integration
```{r}

Sample_names <- c("CTRL_1", "CTRL_2", "4Gy_1", "4Gy_2")

Sample_list <- 
  lapply(X = Sample_names, FUN = function(sample){
    Read10X(data.dir = paste0("Samples/SVZ_", sample),
            gene.column = 1,
            cell.column = 1,
            unique.features = TRUE,
            strip.suffix = TRUE) %>%
      CreateSeuratObject(project = sample,
                         assay = "RNA",
                         min.cells = 0,
                         min.features = 1)
  })
```

Use BioMart as a reference for all features (features are shared amongst samples)
```{r}
Biomart_annotated <- getBM(attributes = c("ensembl_gene_id", 
                                          "external_gene_name",
                                          "description",
                                          "chromosome_name"),
                           filters = "ensembl_gene_id", 
                           values = rownames(Sample_list[[1]]),
                           mart = Ensembl_gene) 
write_csv(Biomart_annotated, file = "Biomart_annotated.csv")
```

Create variables for easy calling of Ensembl Id from External Gene Name (or vice-versa)
```{r}
geneIDs <- # For easy calling of genes through external gene name
  Biomart_annotated[!duplicated(Biomart_annotated$external_gene_name),1]
names(geneIDs) <- Biomart_annotated[!duplicated(Biomart_annotated$external_gene_name),2]
write.csv(x = geneIDs, file = "Analysis_tools/geneIDs.csv")
```

### Quality controls

Extract mitochondrial gene list 
```{r}
MT_genes <- subset(Biomart_annotated,
                   chromosome_name == "MT")$ensembl_gene_id
```

Calculate percentage of mitochondrial genes
```{r}
Sample_list <- lapply(X= Sample_list, FUN = PercentageFeatureSet, 
                   features = MT_genes,
                   col.name = "Percent.mito")
```

Pre-filter cells containing very few features & counts
```{r}
Sample_list <- lapply(X =  Sample_list, FUN = subset,
                   nCount_RNA > 100 & nFeature_RNA > 200)
```

Choose cutoff for features, count minimmums & counts maximum
```{r}
nFeatures_cutoff <- c(1500, 1500, 1800, 1500)
nCounts_cutoff <- c(2350, 2600, 2700, 2700)
nCounts_upper <- c(48000, 54000, 48000, 54000)
```

Create temporary merged object for violin representation of count & feature distribution
```{r}
Temp_merge <- merge(x = Sample_list[[1]],
                    y = c(Sample_list[[2]], Sample_list[[3]], Sample_list[[4]]),
                    add.cell.ids = Sample_names)
VlnPlot(Temp_merge, features = "nCount_RNA", pt.size = 0) + 
    scale_y_continuous(limits = c(200,60000), trans = "log2", breaks = c(100,1000,2000,5000,10000,30000,60000))
VlnPlot(Temp_merge, features = "nFeature_RNA", pt.size = 0) + 
    scale_y_continuous(limits = c(200,15000), trans = "log2", breaks = c(200,1000,2000,5000,10000,15000))
rm(Temp_merge)
```

Histogram representation of cutoff points
```{r}
Hist_cutoffs <- lapply(X = 1:4, FUN = function(spl_nb){
  ggplot(Sample_list[[spl_nb]]@meta.data,
      aes(x = nFeature_RNA, y = nCount_RNA, colour = Percent.mito)) +
      geom_point() + scale_color_gradient2(low = "green", mid = "yellow",
                                           high = "red", midpoint = 20) +
      geom_hline(yintercept = nCounts_cutoff[spl_nb]) +
      geom_hline(yintercept = nCounts_upper[spl_nb]) +
      geom_vline(xintercept = nFeatures_cutoff[spl_nb]) +
    scale_y_log10() + ggtitle(label = Sample_list[[spl_nb]]@project.name)
})
(Hist_cutoffs[[1]] + Hist_cutoffs[[2]])/(Hist_cutoffs[[3]] + Hist_cutoffs[[4]])+ 
  plot_layout(guides = 'collect')
```
Subsetting cells that meet Feature, Genes, and mitochondrial content criterias.

In this analysis, we retained only cells containing <10% of mitochondrial genes.
```{r}
Sample_list <- mapply(
  FUN = function(object, nC, nF, nC_up) {
    return(subset(
      object,
      (
        nCount_RNA > nC &
          nFeature_RNA > nF &
          Percent.mito < 10 &
          nCount_RNA < nC_up
      )
    ))
  },
  object = Sample_list,
  nC = nCounts_cutoff,
  nF = nFeatures_cutoff,
  nC_up = nCounts_upper
)
```

Useful metadata addition & object save

```{r}
Sample_list <- lapply(X = length(Sample_list), FUN = function(Spl_nb){
  Sample_list[[Spl_nb]]$id_sequence <- colnames(Sample_list[[Spl_nb]])
  ID <- paste0(colnames(Sample_list[[Spl_nb]]), "_", Spl_nb)
  names(ID) <- colnames(Sample_list[[Spl_nb]])
  Sample_list[[Spl_nb]]$id <- ID
  return(Sample_list[[Spl_nb]])
})
```

In this analysis, we used 4000 variable features and 10000 cells to normalize UMIs
We also used 4000 variables for integration

```{r}
Sample_list <- lapply(X = Sample_list, 
                   FUN = SCTransform,
                   variable.features.n=4000,
                   return.only.var.genes = F)
```

We can then proceed to finding integration features based on the 4000 variable features, 
and carry on with the standard SCT integration workflow
Note that this results in an integrated assay, but that differential expression 
analysis will require an additional normalization step, using the PrepSCTIntegration function.
```{r}
Integration_Features <- SelectIntegrationFeatures(object.list = Sample_list, 
                                                  nfeatures = 4000,
                                                  assay = rep("SCT",4))

Sample_list <- PrepSCTIntegration(object.list = Sample_list,
                               anchor.features = Integration_Features)

Sample_list <- 
  FindIntegrationAnchors(object.list =Sample_list, normalization.method = "SCT",
                         anchor.features = Integration_Features)

SCT_obj <- IntegrateData(anchorset = Sample_list, normalization.method = "SCT")
```

The cell cycle scoring feature of seurat affects a S and G2/M score to each cell.
For basic classification, cell cycle status can be inferred from the difference between S and G2M score
```{r}
DefaultAssay(SCT_obj) <- "SCT"
cc.genes.mouse <- lapply(X = cc.genes.updated.2019, FUN = str_to_sentence)
cc.mouse.ok <- lapply(X = cc.genes.mouse, function(gene_vector){
  return(Biomart_annotated[Biomart_annotated$external_gene_name %in% gene_vector,1])})
SCT_obj <- CellCycleScoring(SCT_obj, 
                            s.features = cc.mouse.ok$s.genes,
                            g2m.features = cc.mouse.ok$g2m.genes)
# A Diff score can be used to regress the cell cycle
SCT_obj$diff_score <- SCT_obj$S.Score - SCT_obj$G2M.Score
```

Run PCA and assess explained variance using ElbowPlot
```{r}
DefaultAssay(SCT_obj) <- "integrated"
SCT_obj <- RunPCA(object = SCT_obj)
((PCAPlot(SCT_obj, group.by = "orig.ident")+
    ElbowPlot(SCT_obj, ndims = 50, reduction = "pca"))+
    plot_layout(guides = 'collect'))
```

UMAP is created using the first 50 PCs and clusterization is performed based on that graph.
Clustree is used to determine optimal resolution
```{r}
DefaultAssay(SCT_obj) <- "integrated"
SCT_obj <- RunUMAP(SCT_obj,
                   dims = 1:50,
                   n.components = 2L,# 3L for downstream 3D UMAP representation, will affect 2D UMAP
                   assay = "integrated",
                   return.model = T) # Useful for downstream pseudotime applications 

UMAPPlot(object = SCT_obj, group.by = "orig.ident")

SCT_obj <- FindNeighbors(SCT_obj, k.param = 20, dims = c(1:39), reduction = "pca",
                         graph.name = c("int_20_nn", "int_20_snn"))
resolutions <- seq(0.2,1.6, 0.2)
SCT_obj <- FindClusters(SCT_obj, 
                        graph.name = "int_20_snn", 
                        resolution = resolutions)
pdf("Analysis_tools/UMAP_resolutions.pdf")
lapply(X = resolutions, FUN = function(resolv){
  print(UMAPPlot(SCT_obj, 
                 group.by = paste0("int_20_snn_res.", resolv), label = T))
  return()})
dev.off()
```

Based on these data, we found resolution 1.2 to be optimal to distinguish between NPC populations
```{r}
SCT_obj$clusters <- SCT_obj$int_20_snn_res.1.2
UMAPPlot(SCT_obj, group.by = "clusters")
```

Adding irradiation status metadata on samples
```{r}
Idents(SCT_obj) <- "orig.ident"
Status_info <- c("CTL","CTL", "IRR","IRR")
Sample_names <- as.factor(c("CTRL_1", "CTRL_2", "4Gy_1", "4Gy_2"))
names(Status_info) <- Sample_names
SCT_obj <- RenameIdents(SCT_obj, Status_info)
SCT_obj$Status <- Idents(SCT_obj)

saveRDS(object = SCT_obj, file = "SCT_obj_umap.rds")
```

